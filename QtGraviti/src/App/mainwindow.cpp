#include "mainwindow.h"
#include "ui_mainwindow.h"
#include "TrajectoryRenderer.h"
#include "controllers/SimulationControl.h"
#include "controllers/EntityListController.h"
#include "GravitiLib/EntityManager.h"
#include <QQuickWidget>
#include <QUrl>
#include <QDebug>
#include <QSizePolicy>
#include <QString>
#include <QFileDialog>
#include <QMessageBox>
#include <QAction>
#include <QQuickItem>

const float PI = 3.14159265358979323846;

MainWindow::MainWindow(TrajectoryRenderer* trajectoryRenderer, SimulationController* controller, QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
    , m_controller(controller)
    , m_renderer(trajectoryRenderer)
    , m_entityModel(nullptr)
    , m_updateScheduled(false)
{
    //Call autogenerated setup function and assign contexts to expose data to QML
    ui->setupUi(this);
    ui->quickWidget->rootContext()->setContextProperty("trajectoryRenderer", m_renderer);
    ui->quickWidget->rootContext()->setContextProperty("simController", controller);
    ui->quickWidget->rootContext()->setContextProperty("followEntityName", QString(""));

    //Set 3D view to the main qml file
    ui->quickWidget->setSource(QUrl("qrc:/sources/src/App/qml/main.qml"));

    //Connect buttons to actions
    connect(ui->pushButton, &QPushButton::clicked, this, &MainWindow::onStartSimulationClicked);
    connect(ui->pushButton_2, &QPushButton::clicked, this, &MainWindow::onResetSimulationClicked);
    connect(ui->pushButton_3, &QPushButton::clicked, this, &MainWindow::onClearEntitiesClicked);
    connect(ui->AddEntity, &QPushButton::clicked, this, &MainWindow::onAddEntityClicked);
    connect(ui->actionSave_Entities, &QAction::triggered, this, &MainWindow::onSaveEntitiesClicked);
    connect(ui->actionLoad_Entities, &QAction::triggered, this, &MainWindow::onLoadEntitiesClicked);
    connect(ui->batchButton, &QPushButton::clicked, this, &MainWindow::onBatchSimulationClicked);


    //Setup entity list model
    m_entityModel = new QStandardItemModel(this);
    ui->treeView->setModel(m_entityModel);
    ui->treeView->setHeaderHidden(false);

    //Call first update
    EntityListController::setupEntityList(m_entityModel);
    updateTextureCombos();

    updateEntityList();
    updateRender();

    // Populate follow combo and connect selection
    updateFollowCombo();
    connect(ui->followCombo, &QComboBox::currentTextChanged, this, [this](const QString& text) {
        const QString value = (text == "None") ? QString("") : text;
        m_renderer->lockCameraEntity(value.toStdString());
        m_renderer->updateEntitySpheres();
    });
}

MainWindow::~MainWindow()
{
    delete ui;
}

QQmlContext* MainWindow::rootContext()
{
    return ui->quickWidget->rootContext();
}

void MainWindow::updateRender(int sphereCount)
{
    m_renderer->updateEntitySpheres();
}

void MainWindow::updateEntityList()
{
    if (!m_controller || !m_entityModel) {
        return;
    }
    EntityListController::updateEntityList(m_entityModel);
    updateFollowCombo();
    updateParentCombo();
}

void MainWindow::refreshEntityList()
{
    updateEntityList();
}

void MainWindow::updateTextureCombos()
{
    const std::vector<std::string> textures = EntityListController::getTextureList();

    // We have to update both combo boxes, a better design would share the combo box
    ui->EntityTextureCombo->clear();
    ui->EntityTextureCombo->addItem("None");

    ui->comboBox_2->clear();
    ui->comboBox_2->addItem("None");

    for (const auto& texture : textures) {
        const QString qTex = QString::fromStdString(texture);
        ui->EntityTextureCombo->addItem(qTex);
        ui->comboBox_2->addItem(qTex);
    }

    ui->EntityTextureCombo->setCurrentIndex(0);
    ui->comboBox_2->setCurrentIndex(0);
}

void MainWindow::onStartSimulationClicked()
{
    if (!m_controller) {
        return;
    }

    if (!m_isRunning) {
        // Get values from the line edit fields
        int numSteps = ui->lineEdit_10->text().toInt();
        float tickDuration = ui->lineEdit_9->text().toFloat();
        int spheresPerEntity = ui->lineEdit_11->text().toInt();
        int simScalar = ui->lineEdit_12->text().toInt();

        //Clear future trajectories when starting real time
        m_controller->resetBatch();
        m_renderer->resetSpheres();
        updateRender(spheresPerEntity);
        updateEntityList();

        // Ensure that dependency injection update function is stored
        m_controller->setUpdateFunction([this, spheresPerEntity] {
            if (m_updateScheduled.load())
            {
                return;
            }
            m_updateScheduled.store(true);
            QMetaObject::invokeMethod(this, [this, spheresPerEntity] {
                updateRender(spheresPerEntity);
                updateEntityList();
                m_updateScheduled.store(false);
            }, Qt::QueuedConnection);
        });

        // Start (or resume) simulation
        m_isRunning = true;
        m_controller->startSimulation(numSteps, tickDuration, simScalar);
        ui->pushButton->setText("Pause Simulation");
    } else {
        // Pause simulation
        m_controller->pauseSimulation();
        m_isRunning = false;
        ui->pushButton->setText("Resume Simulation");
    }

}

void MainWindow::onBatchSimulationClicked()
{
	// Only allow batch simulation while real-time sim is paused
	if (m_isRunning) {
		QMessageBox::warning(this, "Simulation Running", "Pause the simulation before running a batch simulation.");
		return;
	}

	int numSteps = ui->lineEdit_10->text().toInt();
	float tickDuration = ui->lineEdit_9->text().toFloat();
	int spheresPerEntity = ui->lineEdit_11->text().toInt();

	m_controller->bathProcessFuture(numSteps, tickDuration);

	// Generate trajectory spheres from past trajectories and update the render
	m_renderer->convertTrajectoriesToSpheres(spheresPerEntity, 0.01f);
	updateRender(spheresPerEntity); // update entity spheres to current (post-batch) positions while paused
	updateEntityList();
}

void MainWindow::onResetSimulationClicked()
{
    if (!m_controller) {
        return;
    }
    m_controller->resetSimulation();
    m_renderer->clearEntitySpheres();
    updateRender(0);
    updateEntityList();
    m_isRunning = false;
    ui->pushButton->setText("Start Simulation");
}

void MainWindow::onClearEntitiesClicked()
{
    m_controller->clearEntities();
    if (m_renderer) {
        m_renderer->clearEntitySpheres();
    }
    onResetSimulationClicked();
    // Reset follow selection
    updateFollowCombo();
    // Do not change running state; just refresh
}

void MainWindow::updateFollowCombo()
{
    QString previous = ui->followCombo->currentText();
    ui->followCombo->clear();
    ui->followCombo->addItem("None");

    auto manager = EntityManager::getInstance();
    auto entities = manager->getAllEntities();
    if (entities) {
        for (auto& e : *entities) {
            ui->followCombo->addItem(QString::fromStdString(e.getEntityName()));
        }
    }

    int index = ui->followCombo->findText(previous);
    if (index >= 0 && previous != "None") {
        ui->followCombo->setCurrentIndex(index);
    }
}

void MainWindow::updateParentCombo()
{
    QString previous = ui->comboBox->currentText();
    ui->comboBox->clear();

    auto manager = EntityManager::getInstance();
    auto entities = manager->getAllEntities();
    if (entities) {
        for (auto& e : *entities) {
            ui->comboBox->addItem(QString::fromStdString(e.getEntityName()));
        }
    }

    int index = ui->comboBox->findText(previous);
    if (index >= 0) {
        ui->comboBox->setCurrentIndex(index);
    }
}

void MainWindow::onAddEntityClicked()
{
    if (!m_controller) {
        return;
    }

    // Determine which Add Entity tab is active
    int addTabIndex = ui->tabWidget_2->currentIndex();
    if (addTabIndex == 0) {
        // Absolute Position tab
        QString name = ui->lineEdit->text();
        if (name.isEmpty()) {
            return;
        }

        float posX = ui->lineEdit_5->text().toFloat();
        float posY = ui->lineEdit_4->text().toFloat();
        float posZ = ui->lineEdit_6->text().toFloat();

        float velX = ui->lineEdit_7->text().toFloat();
        float velY = ui->lineEdit_3->text().toFloat();
        float velZ = ui->lineEdit_2->text().toFloat();

        float mass = ui->lineEdit_8->text().toFloat();

        float rad = ui->lineEdit_17->text().toFloat();

        QString texSel = ui->EntityTextureCombo->currentText();
        std::string texPath = (texSel == "None") ? "" : texSel.toStdString();

        m_controller->createEntity(name.toStdString(), posX, posY, posZ, velX, velY, velZ, mass, rad, texPath);

        // Clear absolute fields
        ui->lineEdit->clear();
        ui->lineEdit_5->clear();
        ui->lineEdit_4->clear();
        ui->lineEdit_6->clear();
        ui->lineEdit_7->clear();
        ui->lineEdit_3->clear();
        ui->lineEdit_2->clear();
        ui->lineEdit_8->clear();
        ui->lineEdit_17->clear();
    } else {
        // Relative Position tab
        QString name = ui->lineEdit_16->text();
        if (name.isEmpty()) {
            return;
        }

        QString parentName = ui->comboBox->currentText();
        auto manager = EntityManager::getInstance();
        auto entities = manager->getAllEntities();
        if (!entities || entities->empty()) {
            return;
        }

        // Match names
        Entity* parentEntityPtr = nullptr;
        for (auto& e : *entities) {
            if (QString::fromStdString(e.getEntityName()) == parentName) {
                parentEntityPtr = &e;
                break;
            }
        }
        if (!parentEntityPtr) {
            return;
        }

        auto parentState = parentEntityPtr->getPhysicalState();
        Vec3 parentPos = parentState->getPosition();
        Vec3 parentVel = parentState->getVelocity();
        float parentMass = parentState->getMass();

        float altitude = ui->lineEdit_13->text().toFloat();
        float inclinationDeg = ui->lineEdit_14->text().toFloat();
        float velocityValue = ui->lineEdit_15->text().toFloat();
        float radius = ui->lineEdit_18->text().toFloat();

        float r = altitude;

        // Build inclined orbit geometry:
        // Start radius along +Y, rotate around X by inclination
        float rad = inclinationDeg * (PI / 180.0f);
        float cosI = std::cos(rad);
        float sinI = std::sin(rad);

        Vec3 rRel = { 0.0f, r * cosI, r * sinI };
        Vec3 vRel = { velocityValue, 0.0f, 0.0f };

        float posX = parentPos.x + rRel.x;
        float posY = parentPos.y + rRel.y;
        float posZ = parentPos.z + rRel.z;

        float velX = parentVel.x + vRel.x;
        float velY = parentVel.y + vRel.y;
        float velZ = parentVel.z + vRel.z;

        // TODO - add mass field to relative tab
        float mass = 1.0e10f;

        QString texSelRel = ui->comboBox_2->currentText();
        std::string texPathRel = (texSelRel == "None") ? "" : texSelRel.toStdString();

        m_controller->createEntity(name.toStdString(), posX, posY, posZ, velX, velY, velZ, mass, radius, texPathRel);

        // Clear relative fields
        ui->lineEdit_16->clear();
        ui->lineEdit_13->clear();
        ui->lineEdit_14->clear();
        ui->lineEdit_15->clear();
        ui->lineEdit_18->clear();
    }

    updateRender();
    updateEntityList();
}

void MainWindow::onSaveEntitiesClicked()
{
    if (!m_controller) {
        return;
    }

    QString fileName = QFileDialog::getSaveFileName(this, "Save Entities", "", "JSON Files (*.json);;All Files (*)");

    if (!fileName.isEmpty()) {
        try {
            m_controller->saveEntitiesAsJson(fileName.toStdString());
            QMessageBox::information(this, "Success", "Entities saved successfully to " + fileName);
        } catch (const std::exception& e) {
            QMessageBox::critical(this, "Error", "Failed to save entities: " + QString::fromStdString(e.what()));
        }
    }
}

void MainWindow::onLoadEntitiesClicked()
{
    if (!m_controller) {
        QMessageBox::warning(this, "Error", "Simulation controller not available.");
        return;
    }

    QString fileName = QFileDialog::getOpenFileName(this, "Load Entities", "", "JSON Files (*.json);;All Files (*)");

    if (!fileName.isEmpty()) {
        try {
            m_controller->clearEntities();
            m_controller->initialize_json_body(fileName.toStdString());
            updateEntityList();
            updateRender();
            QMessageBox::information(this, "Success", "Entities loaded successfully from " + fileName);
        } catch (const std::exception& e) {
            QMessageBox::critical(this, "Error", "Failed to load entities: " + QString::fromStdString(e.what()));
        }
    }
}